Controlling Bean Selections
    @Primary - to set one bean as primary when we have multiple beans
    @Qualifier - specifying a specific bean


Externalizing configurations (application.properties):
    This part explains how to get the value from application.properties
    in order to access any parameter from the application.properties we need to use
    the @Value("${parameterName}") annotation.

    #   we can also set a default value to a parameter even if they are not declare on
        the application.properties

            @Value("${stripe.timeout:3000}")
            private Double timeOut;

        Here if there is no such property declared as stripe.timeout; the system will work
        with the default one. But if there is one, spring boot will overwrite that onw
        with the default one.

Externalizing configurations (application.yaml):
    both .yaml and .properties are configuration files and both can exist individually. But
    it's better to follow only one configuration file so I am deleting application.properties file


Lazy initialization:
    @Lazy - to delay the initialization of a bean until it is needed.
    This is useful for improving startup time and reducing memory consumption.
    By default, Spring initializes all singleton beans at startup. However, by using
    the @Lazy annotation, you can specify that a bean should be created only when it is
    first requested. If we want to create bean from the using code like AppConfig class
    we can use @Lazy annotation on the method that creates the bean.


Bean Scopes:
    It determines the lifecycle and visibility of a bean in the Spring container.
    The most common scopes are:
    Singleton - only one instance of the bean is created and shared across the application.
    Prototype - a new instance of the bean is created each time it is requested.
    Request - a new instance of the bean is created for each HTTP request (web applications).
    Session - a new instance of the bean is created for each HTTP session (web applications).
    Application - a single instance of the bean is created for the lifecycle of a ServletContext
    (web applications).

Bean Lifecycle Hooks:
    @PostConstruct - to define a method that should be executed after the bean is created
    and dependencies are injected.
    @PreDestroy - to define a method that should be executed before the bean is destroyed.
    These annotations are useful for performing initialization and cleanup tasks for beans.


Database migration with Flyway:
    Flyway is a database migration tool that helps manage and version control database
    schema changes.
    To use Flyway in a Spring Boot application, you typically include the Flyway dependency
    in your project and configure the database connection properties in the application.properties
    or application.yaml file. Flyway will then automatically apply any pending migrations
    when the application starts. It look for the migration files in the default location
    "db/migration" under the resources folder. and the migration files should follow a specific
    naming convention, such as V1__Initial_setup.sql, V2__Add_new_table


Implementing one-to-many relationship with JPA:
    In JPA, a one-to-many relationship is established using the @OneToMany and @ManyToOne
    annotations. The entity that contains the collection of related entities is annotated
    with @OneToMany, while the entity that is being referenced is annotated with @ManyToOne.
    For example, consider a scenario where we have two entities: Author and Book. An Author
    can have multiple Books, but each Book is associated with only one Author.

    In the Author entity, we would define the one-to-many relationship as follows:

        @Entity
        public class Author {
            @Id
            @GeneratedValue(strategy = GenerationType.IDENTITY)
            private Long id;

            private String name;

            @OneToMany(mappedBy = "author")
            private List<Book> books;

            // getters and setters
        }

    In the Book entity, we would define the many-to-one relationship as follows:

        @Entity
        public class Book {
            @Id
            @GeneratedValue(strategy = GenerationType.IDENTITY)
            private Long id;

            private String title;

            @ManyToOne
            @JoinColumn(name = "author_id")
            private Author author;

            // getters and setters
        }


Implementing many-to-many relationship with JPA:
    In JPA, a many-to-many relationship is established using the @ManyToMany annotation.
    This relationship requires a join table to link the two entities together.
    For example, consider a scenario where we have two entities: Student and Course.
    A Student can enroll in multiple Courses, and a Course can have multiple Students enrolled.

    In the Student entity, we would define the many-to-many relationship as follows:

        @Entity
        public class Student {
            @Id
            @GeneratedValue(strategy = GenerationType.IDENTITY)
            private Long id;

            private String name;

            @ManyToMany
            @JoinTable(
                name = "student_course",
                joinColumns = @JoinColumn(name = "student_id"),
                inverseJoinColumns = @JoinColumn(name = "course_id")
            )
            private List<Course> courses;

            // getters and setters
        }

    In the Course entity, we would define the many-to-many relationship as follows:

        @Entity
        public class Course {
            @Id
            @GeneratedValue(strategy = GenerationType.IDENTITY)
            private Long id;

            private String title;

            @ManyToMany(mappedBy = "courses")
            private List<Student> students;

            // getters and setters
        }

Implementing One-to-One relationship with JPA:
    In JPA, a one-to-one relationship is established using the @OneToOne annotation.
    This relationship indicates that one entity is associated with exactly one instance
    of another entity. For example, consider a scenario where we have two entities:
    User and Profile. Each User has one Profile, and each Profile is associated with
    one User.

    In the User entity, we would define the one-to-one relationship as follows:

        @Entity
        public class User {
            @Id
            @GeneratedValue(strategy = GenerationType.IDENTITY)
            private Long id;

            private String username;

            @OneToOne()
            @JoinColumn(name = "profile_id")
            private Profile profile;

            // getters and setters
        }

    In the Profile entity, we would define the one-to-one relationship as follows:

        @Entity
        public class Profile {
            @Id
            @GeneratedValue(strategy = GenerationType.IDENTITY)
            private Long id;

            private String bio;

            @OneToOne(mappedBy = "profile")
            private User user;

            // getters and setters
        }

Generating Entities using JPA Buddy:
    JPA Buddy is a powerful IDE plugin that simplifies the process of working with
    JPA and Hibernate in Java applications. It provides a user-friendly interface
    for generating JPA entities, repositories, and other related components.

    To generate entities using JPA Buddy, you typically follow these steps:
    1. Install JPA Buddy plugin in your IDE (e.g., IntelliJ IDEA).
    2. Open your project and navigate to the JPA Buddy tool window.(rignt click on the folder add new and select JPA Entity from DB)
    3. Use the JPA Buddy interface to create new entities, define attributes,
       and establish relationships between entities.
    4. JPA Buddy will generate the necessary Java classes and annotations based
       on your specifications.
    5. Review and customize the generated code as needed for your application.



Managing Transactions:
    In Spring, transactions can be managed using the @Transactional annotation.
    This annotation can be applied at the class or method level to define the
    scope of a transaction. When a method annotated with @Transactional is called,
    Spring will start a new transaction, and if the method completes successfully,
    the transaction will be committed. If an exception occurs, the transaction
    will be rolled back.

    For example, consider a service class that performs database operations:

        @Service
        public class UserService {
            @Autowired
            private UserRepository userRepository;

            @Transactional
            public void createUser(User user) {
                userRepository.save(user);
                // additional operations
            }
        }

    In this example, the createUser method is annotated with @Transactional,
    indicating that it should be executed within a transaction. If any exception
    occurs during the execution of this method, all changes made within the transaction
    will be rolled back to maintain data integrity.

Fetching Strategies in JPA:
    In JPA, fetching strategies determine how related entities are loaded from the database.
    There are two main fetching strategies: EAGER and LAZY.

    EAGER Fetching:
        When an association is marked as EAGER, the related entity is loaded immediately
        along with the parent entity. This means that when you retrieve the parent entity,
        all its associated entities are also fetched from the database in a single query.
        EAGER fetching can lead to performance issues if there are many related entities,
        as it may result in large result sets and increased memory consumption.

    LAZY Fetching:
        When an association is marked as LAZY, the related entity is not loaded until it
        is explicitly accessed. This means that when you retrieve the parent entity,
        the associated entities are not fetched from the database until you try to access
        them. LAZY fetching can improve performance by reducing the amount of data
        retrieved from the database, especially when dealing with large collections
        of related entities. However, it can lead to LazyInitializationException if
        the associated entities are accessed outside of an active session or transaction.

    By default, @OneToMany and @ManyToMany associations are LAZY, while @ManyToOne
    and @OneToOne associations are EAGER. However, you can explicitly specify the
    fetching strategy using the fetch attribute of the association annotations:

        @OneToMany(fetch = FetchType.LAZY)
        private List<Book> books;

        @ManyToOne(fetch = FetchType.EAGER)
        private Author author;



Projections:
    Projections in JPA allow you to retrieve a subset of entity attributes
    instead of the entire entity. This can be useful for optimizing performance
    and reducing the amount of data transferred from the database.

    There are two main types of projections in JPA: Interface-based projections
    and Class-based projections.

    Interface-based Projections:
        In this approach, you define an interface that specifies the attributes
        you want to retrieve. JPA will then create a proxy implementation of
        this interface at runtime. For example:

            public interface UserProjection {
                String getUsername();
                String getEmail();
            }

        You can then use this projection in your repository method:

            List<UserProjection> findByActiveTrue();

    Class-based Projections:
        In this approach, you define a DTO (Data Transfer Object) class that
        contains the attributes you want to retrieve. You can then use a JPQL
        query to populate instances of this DTO class. For example:

            public class UserDTO {
                private String username;
                private String email;

                public UserDTO(String username, String email) {
                    this.username = username;
                    this.email = email;
                }

                // getters and setters
            }

        You can then use this DTO in your repository method:

            @Query("SELECT new com.example.UserDTO(u.username, u.email) FROM User u WHERE u.active = true")
            List<UserDTO> findActiveUsers();

EntityGraph Annotation:
    The @EntityGraph annotation in JPA is used to define a graph of entities
    that should be fetched together in a single query. This is particularly useful
    for optimizing performance and avoiding the N+1 select problem when dealing
    with associations between entities.

    By using @EntityGraph, you can specify which related entities should be
    eagerly loaded along with the main entity, allowing you to control the
    fetching behavior more precisely.

    For example, consider two entities: Author and Book, where an Author has
    a one-to-many relationship with Book. You can define an entity graph
    to fetch an Author along with their associated Books as follows:

        @Entity
        @NamedEntityGraph(
            name = "Author.books",
            attributeNodes = @NamedAttributeNode("books")
        )
        public class Author {
            @Id
            @GeneratedValue(strategy = GenerationType.IDENTITY)
            private Long id;

            private String name;

            @OneToMany(mappedBy = "author")
            private List<Book> books;

            // getters and setters
        }

    You can then use this entity graph in your repository method:

        @EntityGraph(value = "Author.books", type = EntityGraph.EntityGraphType.LOAD)
        Optional<Author> findById(Long id);


N+1 problem:
    The N+1 problem is a common performance issue that occurs when an application
    retrieves a collection of entities and then, for each entity in that collection,
    it performs an additional query to fetch related entities. This results in
    N+1 queries being executed, where N is the number of entities in the initial
    collection.

    For example, consider a scenario where you have two entities: Author and Book,
    with a one-to-many relationship between them (an Author can have multiple Books).
    If you retrieve a list of Authors and then access their associated Books,
    you might end up executing one query to fetch the Authors and then N additional
    queries to fetch the Books for each Author.

    This can lead to significant performance degradation, especially when dealing
    with large datasets, as the number of queries executed increases linearly
    with the number of entities.

    To mitigate the N+1 problem, you can use techniques such as:
    1. Eager fetching: Configure the relationship to use eager fetching so that
       related entities are loaded in a single query.
    2. Join fetching: Use JPQL or Criteria API to perform a join fetch, retrieving
       both the parent and related entities in a single query.
    3. Entity graphs: Use the @EntityGraph annotation to define which related
       entities should be fetched together.
    4. Batch fetching: Configure batch fetching settings in your JPA provider
       to load related entities in batches rather than individually.



Stored Procedures:
    Stored procedures are precompiled SQL statements that are stored in the database
    and can be executed by the database engine. They are used to encapsulate complex
    business logic, improve performance, and enhance security by reducing the amount
    of SQL code sent from the application to the database.

    Here is an example of a stored procedure that retrieves products within a specified price range from a "products" table:

    DELIMITER $$ -- Change the statement delimiter to $$ to allow for multi-line procedure definition. It allows the entire procedure to be defined as a single statement.

    CREATE PROCEDURE findProductsByPrice(
        minPrice DECIMAL(10, 2),
        maxPrice DECIMAL(10, 2)
    )
    BEGIN
    SELECT id, name, price, category_id
    FROM products
    WHERE price BETWEEN minPrice AND maxPrice
    ORDER BY name;

    END $$

    DELIMITER ; -- Reset the statement delimiter back to the default ;

    To check if the stored procedure is created successfully and works, you can use the following command:
    CALL findProductsByPrice(10, 2000);

    In your Spring Data JPA repository, you can call this stored procedure using the @Procedure annotation as follows:
    @Procedure("findProductsByPrice")
    List<Product> findProducts(BigDecimal min, BigDecimal max);
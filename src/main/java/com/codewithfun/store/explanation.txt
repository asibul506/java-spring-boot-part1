Controlling Bean Selections
    @Primary - to set one bean as primary when we have multiple beans
    @Qualifier - specifying a specific bean


Externalizing configurations (application.properties):
    This part explains how to get the value from application.properties
    in order to access any parameter from the application.properties we need to use
    the @Value("${parameterName}") annotation.

    #   we can also set a default value to a parameter even if they are not declare on
        the application.properties

            @Value("${stripe.timeout:3000}")
            private Double timeOut;

        Here if there is no such property declared as stripe.timeout; the system will work
        with the default one. But if there is one, spring boot will overwrite that onw
        with the default one.

Externalizing configurations (application.yaml):
    both .yaml and .properties are configuration files and both can exist individually. But
    it's better to follow only one configuration file so I am deleting application.properties file


Lazy initialization:
    @Lazy - to delay the initialization of a bean until it is needed.
    This is useful for improving startup time and reducing memory consumption.
    By default, Spring initializes all singleton beans at startup. However, by using
    the @Lazy annotation, you can specify that a bean should be created only when it is
    first requested. If we want to create bean from the using code like AppConfig class
    we can use @Lazy annotation on the method that creates the bean.


Bean Scopes:
    It determines the lifecycle and visibility of a bean in the Spring container.
    The most common scopes are:
    Singleton - only one instance of the bean is created and shared across the application.
    Prototype - a new instance of the bean is created each time it is requested.
    Request - a new instance of the bean is created for each HTTP request (web applications).
    Session - a new instance of the bean is created for each HTTP session (web applications).
    Application - a single instance of the bean is created for the lifecycle of a ServletContext
    (web applications).

Bean Lifecycle Hooks:
    @PostConstruct - to define a method that should be executed after the bean is created
    and dependencies are injected.
    @PreDestroy - to define a method that should be executed before the bean is destroyed.
    These annotations are useful for performing initialization and cleanup tasks for beans.


Database migration with Flyway:
    Flyway is a database migration tool that helps manage and version control database
    schema changes.
    To use Flyway in a Spring Boot application, you typically include the Flyway dependency
    in your project and configure the database connection properties in the application.properties
    or application.yaml file. Flyway will then automatically apply any pending migrations
    when the application starts. It look for the migration files in the default location
    "db/migration" under the resources folder. and the migration files should follow a specific
    naming convention, such as V1__Initial_setup.sql, V2__Add_new_table


Implementing one-to-many relationship with JPA:
    In JPA, a one-to-many relationship is established using the @OneToMany and @ManyToOne
    annotations. The entity that contains the collection of related entities is annotated
    with @OneToMany, while the entity that is being referenced is annotated with @ManyToOne.
    For example, consider a scenario where we have two entities: Author and Book. An Author
    can have multiple Books, but each Book is associated with only one Author.

    In the Author entity, we would define the one-to-many relationship as follows:

        @Entity
        public class Author {
            @Id
            @GeneratedValue(strategy = GenerationType.IDENTITY)
            private Long id;

            private String name;

            @OneToMany(mappedBy = "author")
            private List<Book> books;

            // getters and setters
        }

    In the Book entity, we would define the many-to-one relationship as follows:

        @Entity
        public class Book {
            @Id
            @GeneratedValue(strategy = GenerationType.IDENTITY)
            private Long id;

            private String title;

            @ManyToOne
            @JoinColumn(name = "author_id")
            private Author author;

            // getters and setters
        }


Implementing many-to-many relationship with JPA:
    In JPA, a many-to-many relationship is established using the @ManyToMany annotation.
    This relationship requires a join table to link the two entities together.
    For example, consider a scenario where we have two entities: Student and Course.
    A Student can enroll in multiple Courses, and a Course can have multiple Students enrolled.

    In the Student entity, we would define the many-to-many relationship as follows:

        @Entity
        public class Student {
            @Id
            @GeneratedValue(strategy = GenerationType.IDENTITY)
            private Long id;

            private String name;

            @ManyToMany
            @JoinTable(
                name = "student_course",
                joinColumns = @JoinColumn(name = "student_id"),
                inverseJoinColumns = @JoinColumn(name = "course_id")
            )
            private List<Course> courses;

            // getters and setters
        }

    In the Course entity, we would define the many-to-many relationship as follows:

        @Entity
        public class Course {
            @Id
            @GeneratedValue(strategy = GenerationType.IDENTITY)
            private Long id;

            private String title;

            @ManyToMany(mappedBy = "courses")
            private List<Student> students;

            // getters and setters
        }

Implementing One-to-One relationship with JPA:
    In JPA, a one-to-one relationship is established using the @OneToOne annotation.
    This relationship indicates that one entity is associated with exactly one instance
    of another entity. For example, consider a scenario where we have two entities:
    User and Profile. Each User has one Profile, and each Profile is associated with
    one User.

    In the User entity, we would define the one-to-one relationship as follows:

        @Entity
        public class User {
            @Id
            @GeneratedValue(strategy = GenerationType.IDENTITY)
            private Long id;

            private String username;

            @OneToOne()
            @JoinColumn(name = "profile_id")
            private Profile profile;

            // getters and setters
        }

    In the Profile entity, we would define the one-to-one relationship as follows:

        @Entity
        public class Profile {
            @Id
            @GeneratedValue(strategy = GenerationType.IDENTITY)
            private Long id;

            private String bio;

            @OneToOne(mappedBy = "profile")
            private User user;

            // getters and setters
        }

Generating Entities using JPA Buddy:
    JPA Buddy is a powerful IDE plugin that simplifies the process of working with
    JPA and Hibernate in Java applications. It provides a user-friendly interface
    for generating JPA entities, repositories, and other related components.

    To generate entities using JPA Buddy, you typically follow these steps:
    1. Install JPA Buddy plugin in your IDE (e.g., IntelliJ IDEA).
    2. Open your project and navigate to the JPA Buddy tool window.(rignt click on the folder add new and select JPA Entity from DB)
    3. Use the JPA Buddy interface to create new entities, define attributes,
       and establish relationships between entities.
    4. JPA Buddy will generate the necessary Java classes and annotations based
       on your specifications.
    5. Review and customize the generated code as needed for your application.



Managing Transactions:
    In Spring, transactions can be managed using the @Transactional annotation.
    This annotation can be applied at the class or method level to define the
    scope of a transaction. When a method annotated with @Transactional is called,
    Spring will start a new transaction, and if the method completes successfully,
    the transaction will be committed. If an exception occurs, the transaction
    will be rolled back.

    For example, consider a service class that performs database operations:

        @Service
        public class UserService {
            @Autowired
            private UserRepository userRepository;

            @Transactional
            public void createUser(User user) {
                userRepository.save(user);
                // additional operations
            }
        }

    In this example, the createUser method is annotated with @Transactional,
    indicating that it should be executed within a transaction. If any exception
    occurs during the execution of this method, all changes made within the transaction
    will be rolled back to maintain data integrity.

Fetching Strategies in JPA:
    In JPA, fetching strategies determine how related entities are loaded from the database.
    There are two main fetching strategies: EAGER and LAZY.

    EAGER Fetching:
        When an association is marked as EAGER, the related entity is loaded immediately
        along with the parent entity. This means that when you retrieve the parent entity,
        all its associated entities are also fetched from the database in a single query.
        EAGER fetching can lead to performance issues if there are many related entities,
        as it may result in large result sets and increased memory consumption.

    LAZY Fetching:
        When an association is marked as LAZY, the related entity is not loaded until it
        is explicitly accessed. This means that when you retrieve the parent entity,
        the associated entities are not fetched from the database until you try to access
        them. LAZY fetching can improve performance by reducing the amount of data
        retrieved from the database, especially when dealing with large collections
        of related entities. However, it can lead to LazyInitializationException if
        the associated entities are accessed outside of an active session or transaction.

    By default, @OneToMany and @ManyToMany associations are LAZY, while @ManyToOne
    and @OneToOne associations are EAGER. However, you can explicitly specify the
    fetching strategy using the fetch attribute of the association annotations:

        @OneToMany(fetch = FetchType.LAZY)
        private List<Book> books;

        @ManyToOne(fetch = FetchType.EAGER)
        private Author author;



